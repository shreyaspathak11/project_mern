{"version":3,"file":"index.cjs.js","sources":["index.js"],"sourcesContent":["import { lab2rgb, lch2rgb } from '@csstools/convert-colors';\nimport postcss from 'postcss';\nimport parser from 'postcss-values-parser';\n\nexport default postcss.plugin('postcss-lab-function', opts => {\n\tconst preserve = 'preserve' in Object(opts) ? Boolean(opts.preserve) : false;\n\n\treturn root => {\n\t\troot.walkDecls(decl => {\n\t\t\tconst { value } = decl;\n\n\t\t\tif (colorAnyRegExp.test(value)) {\n\t\t\t\tconst ast = parser(value).parse();\n\n\t\t\t\tast.walkType('func', node => {\n\t\t\t\t\tif (colorRegExp.test(node.value)) {\n\t\t\t\t\t\tconst children = node.nodes.slice(1, -1);\n\t\t\t\t\t\tconst isLab = labRegExp.test(node.value);\n\t\t\t\t\t\tconst isGray = grayRegExp.test(node.value);\n\t\t\t\t\t\tconst isFunctionalLAB = !isGray && matchFunctionalLAB(children);\n\t\t\t\t\t\tconst isFunctionalLCH = !isGray && matchFunctionalLCH(children);\n\t\t\t\t\t\tconst isFunctionalGray = isGray && matchFunctionalGray(children);\n\n\t\t\t\t\t\tif (isFunctionalLAB || isFunctionalLCH) {\n\t\t\t\t\t\t\tnode.value = 'rgb';\n\n\t\t\t\t\t\t\tconst slashNode = children[3];\n\t\t\t\t\t\t\tconst alphaNode = children[4];\n\n\t\t\t\t\t\t\tif (alphaNode) {\n\t\t\t\t\t\t\t\tif (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n\t\t\t\t\t\t\t\t\talphaNode.unit = '';\n\t\t\t\t\t\t\t\t\talphaNode.value = String(alphaNode.value / 100);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (alphaNode.value === '1') {\n\t\t\t\t\t\t\t\t\tslashNode.remove();\n\t\t\t\t\t\t\t\t\talphaNode.remove();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode.value += 'a';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (slashNode && isSlash(slashNode)) {\n\t\t\t\t\t\t\t\tslashNode.replaceWith( newComma() );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst converter = isLab ? lab2rgb : lch2rgb;\n\n\t\t\t\t\t\t\tconst rgbValues = converter(\n\t\t\t\t\t\t\t\t...[\n\t\t\t\t\t\t\t\t\tchildren[0].value,\n\t\t\t\t\t\t\t\t\tchildren[1].value,\n\t\t\t\t\t\t\t\t\tchildren[2].value\n\t\t\t\t\t\t\t\t].map(\n\t\t\t\t\t\t\t\t\tnumber => parseFloat(number)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t).map(\n\t\t\t\t\t\t\t\tsourceValue => Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0)\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tchildren[0].value = String(rgbValues[0]);\n\t\t\t\t\t\t\tchildren[1].value = String(rgbValues[1]);\n\t\t\t\t\t\t\tchildren[2].value = String(rgbValues[2]);\n\n\t\t\t\t\t\t\tnode.nodes.splice(3, 0, [ newComma() ]);\n\t\t\t\t\t\t\tnode.nodes.splice(2, 0, [ newComma() ]);\n\t\t\t\t\t\t} else if (isFunctionalGray) {\n\t\t\t\t\t\t\tnode.value = 'rgb';\n\n\t\t\t\t\t\t\tconst alphaNode = children[2];\n\n\t\t\t\t\t\t\tconst rgbValues = lab2rgb(\n\t\t\t\t\t\t\t\t...[\n\t\t\t\t\t\t\t\t\tchildren[0].value,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t\t].map(\n\t\t\t\t\t\t\t\t\tnumber => parseFloat(number)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t).map(\n\t\t\t\t\t\t\t\tsourceValue => Math.max(Math.min(parseInt(sourceValue * 2.55), 255), 0)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tnode.removeAll()\n\t\t\t\t\t\t\t.append(newParen('('))\n\t\t\t\t\t\t\t.append(newNumber(rgbValues[0]))\n\t\t\t\t\t\t\t.append(newComma())\n\t\t\t\t\t\t\t.append(newNumber(rgbValues[1]))\n\t\t\t\t\t\t\t.append(newComma())\n\t\t\t\t\t\t\t.append(newNumber(rgbValues[2]))\n\t\t\t\t\t\t\t.append(newParen(')'));\n\n\t\t\t\t\t\t\tif (alphaNode) {\n\t\t\t\t\t\t\t\tif (isPercentage(alphaNode) && !isCalc(alphaNode)) {\n\t\t\t\t\t\t\t\t\talphaNode.unit = '';\n\t\t\t\t\t\t\t\t\talphaNode.value = String(alphaNode.value / 100);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (alphaNode.value !== '1') {\n\t\t\t\t\t\t\t\t\tnode.value += 'a';\n\n\t\t\t\t\t\t\t\t\tnode\n\t\t\t\t\t\t\t\t\t.insertBefore(node.last, newComma())\n\t\t\t\t\t\t\t\t\t.insertBefore(node.last, alphaNode)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tconst newValue = String(ast);\n\n\t\t\t\tif (preserve) {\n\t\t\t\t\tdecl.cloneBefore({ value: newValue });\n\t\t\t\t} else {\n\t\t\t\t\tdecl.value = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n});\n\nconst colorAnyRegExp = /(^|[^\\w-])(lab|lch|gray)\\(/i;\nconst colorRegExp = /^(lab|lch|gray)$/i;\nconst labRegExp = /^lab$/i;\nconst grayRegExp = /^gray$/i;\nconst alphaUnitMatch = /^%?$/i;\nconst calcFuncMatch = /^calc$/i;\nconst hueUnitMatch = /^(deg|grad|rad|turn)?$/i;\n\nconst isAlphaValue = node => isCalc(node) || node.type === 'number' && alphaUnitMatch.test(node.unit);\nconst isCalc = node => node.type === 'func' && calcFuncMatch.test(node.value);\nconst isHue = node => isCalc(node) || node.type === 'number' && hueUnitMatch.test(node.unit);\nconst isNumber = node => isCalc(node) || node.type === 'number' && node.unit === '';\nconst isPercentage = node => isCalc(node) || node.type === 'number' && node.unit === '%';\nconst isSlash = node => node.type === 'operator' && node.value === '/';\nconst functionalLABMatch = [isNumber, isNumber, isNumber, isSlash, isAlphaValue];\nconst functionalLCHMatch = [isNumber, isNumber, isHue, isSlash, isAlphaValue];\nconst functionalGrayMatch = [isNumber, isSlash, isAlphaValue];\nconst matchFunctionalLAB = children => children.every(\n\t(child, index) => typeof functionalLABMatch[index] === 'function' && functionalLABMatch[index](child)\n);\nconst matchFunctionalLCH = children => children.every(\n\t(child, index) => typeof functionalLCHMatch[index] === 'function' && functionalLCHMatch[index](child)\n);\nconst matchFunctionalGray = children => children.every(\n\t(child, index) => typeof functionalGrayMatch[index] === 'function' && functionalGrayMatch[index](child)\n);\n\nconst newComma = () => parser.comma({ value: ',' });\nconst newNumber = value => parser.number({ value });\nconst newParen = value => parser.paren({ value });\n"],"names":["postcss","plugin","opts","preserve","Object","Boolean","root","walkDecls","decl","value","colorAnyRegExp","test","ast","parser","parse","walkType","node","colorRegExp","children","nodes","slice","isLab","labRegExp","isGray","grayRegExp","isFunctionalLAB","matchFunctionalLAB","isFunctionalLCH","matchFunctionalLCH","isFunctional